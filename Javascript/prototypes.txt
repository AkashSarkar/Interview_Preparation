Every function in javascript has a property called prototypes which references an object.

function Animal (name, energy) {
  let animal = Object.create(Animal.prototype)
  animal.name = name
  animal.energy = energy

  return animal
}

we can deligate a function with Object.create. Here we are passing Animal.prototype and this
is referencing the Animal object.

function Animal (name, energy) {
  this.name = name
  this.energy = energy
}

Animal.prototype.eat = function (amount) {
  console.log(`${this.name} is eating.`)
  this.energy += amount
}

Animal.prototype.sleep = function (length) {
  console.log(`${this.name} is sleeping.`)
  this.energy += length
}

Animal.prototype.play = function (length) {
  console.log(`${this.name} is playing.`)
  this.energy -= length
}

const leo = new Animal('Leo', 7)
const snoop = new Animal('Snoop', 10)

Here we are sharing methods across objects with prototypes. 

Array Methods:

const friendsWithSugar = []

const friendsWithoutSugar = new Array()

These two lines are equevalent.

One thing you might have never thought about is how does every instance of an array
have all of those built in methods (splice, slice, pop, etc)?

Well as you now know, itâ€™s because those methods live on Array.prototype and
when you create a new instance of Array, you use the new keyword which sets up 
that delegation to Array.prototype on failed lookups.

